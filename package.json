{
  "name": "freebase",
  "description": "Pub/sub api as a service using faye and mongo & redis or nedb, can work as cluster, single process or embedded using nedb, use in production at your own risk",
  "version": "0.1.10",
  "main": "./lib/index",
  "keywords": [
    "faye",
    "mongo",
    "redis",
    "nedb"
  ],
  "dependencies": {
    "JSONStream": "^0.10.0",
    "async": "^0.9.0",
    "body-parser": "^1.12.2",
    "byline": "^4.2.1",
    "connect": "^3.3.5",
    "faye": "^1.1.1",
    "faye-redis": "^0.2.0",
    "jwt-simple": "^0.2.0",
    "log4js": "^0.6.22",
    "moment": "^2.9.0",
    "mongodb": "^2.0.24",
    "nedb": "^1.1.1",
    "request": "^2.53.0",
    "shortid": "^2.2.1",
    "traverse": "^0.6.6",
    "underscore": "^1.8.2",
    "underscore.string": "^3.0.3"
  },
  "devDependencies": {
    "mocha": "*",
    "expect.js": "*"
  },
  "gitHead": "36c12fcdec7dacab77e678e7fce7572b84bf3476",
  "readme": "FREEBASE\n=====================\n\nIntroduction\n-------------------------\n\nFreebase is an attempt at getting the same kind of functionality that [firebase](https://www.firebase.com/) offers, but it is free. It is a bit different from firebase in terms of it being a searchable key/value store, instead of arranging the data like one big json tree, like firebase does...\n\nFirebase is fricking awesome - but sometimes priced a little out of the reach of certain projects, but if you have the money to throw at it, it is well worth investigating. \n\nThe aim of this framework however is to create an http/json api that sits on top of a mongo backend as the server, which also has pub/sub baked in - so you can subscribe to changes in the data via the client - which can be used from a browser thanks to [browserify](http://browserify.org), or from a node program, depending on how it is initialized.\n\nTechnologies used:\nFreebase uses [faye](http://faye.jcoglan.com/) for its pub/sub framework and mongo or nedb depending on the mode it is running in as its data store, the API uses [connect](https://github.com/senchalabs/connect), the client uses jquery or request.js depending on whether it is running in the browser.\n\nThe system uses [jwt](https://github.com/hokaccha/node-jwt-simple) to secure session state between calls.\n\nFreebase has 3 modes:\n-----------------------\n\nembedded:\n---------\n\nThis is the easiest setup, as the system uses nedb to store data internally, so you dont need mongo or redis running on your machine. You can just spin up an instance and start pushing data to it and listening for changes via the client.\n\n* NB - the search functionality works slightly differently in embedded mode, $all is not supported, and nested columns like data.firstname dont work, when you try and limit the columns returned - you'll see what I mean if you look at the tests *\n\ncluster: \n--------\n\nYou can specify how many worker processes you want the system to use, so we can scale to multicore machines.\nYou need a redis instance and a mongo instance for this mode, this is because Faye uses it's redis engine to keep state across clustered instances of the Freebase worker process.\n\nsingle process:\n---------------\n\nThe system runs as a single process, but still needs a mongo db instance running for storing data.\n\nadditional info\n---------------\n\nFreebase stores its data in a collection called 'freebase' by default on your mongodb. The freebase system is actually built to be a module, this is because the idea is that you will be able to initialize a server in your own code, and possibly attach your own plugins to various system events. So the requirements and installation instructions show you how to reference freebase and write the code that starts the instance up. This won't be a tremendously detailed document - so please do spelunk and get involved.\n\nRequirements & instructions\n---------------------------\n\nYou need NodeJS and NPM of course, you also need to know how node works (as my setup instructions are pretty minimal)\n\nYou need to install mocha to run the tests, ie: sudo npm install mocha -g --save\n\nIf you want to run in cluster mode, you need to install [Redis](http://redis.io/topics/quickstart) and have it up and running, on its standard port: 6379\n\nIf you want to run in cluster or single process mode, you need to install [Mongo](http://docs.mongodb.org/manual/installation/) and have it up and running on its standard port: 27017\n\nYou can just clone this repository, then run \"npm install\" and then run \"mocha test/e2e_test\" to see how things work, there are 17 unit tests there that execute against freebase service running in embedded mode, they should all pass... \n\nBut if you want to run your own service do the following:\n\nCreate a directory you want to run your freebase in, create a node application in it - with some kind of main.js and a package.json\n\nI havent had the time to join npm yet, so add the following dependancy to your package.json:\n\n```javascript\n\"dependencies\": {\n    \"freebase\": \"git+https://github.com/southbite/freebase.git\"\n  }\n```\nTo get the latest freebase files run:\nnpm install\n\n*In node_modules/freebase/test in your folder, the e2e_test.js script demonstrates the server and client interactions shown in the following code snippets*\n\nTo start up a freebase, add following to your main.js:\n-------------------------------------------------------\n\n```javascript\nvar freebase = require('freebase')\nvar service = freebase.service;\n\n//Embedded mode (no external databases necessary): \nservice.initialize({services:{\n\tauth:{\n\t\tauthTokenSecret:'a256a2fd43bf441483c5177fc85fd9d3',\n\t\tsystemSecret:test_secret\n\t},\n\tdata:{\n\t\tmode:'embedded'\n\t}\n}}, function(e){\n\tcallback(e);\n});\n\n//Cluster mode (needs redis and mongo): \nservice.initialize({mode:'cluster', size:2, port:testport, services:{\n\tauth:{authTokenSecret:'a256a2fd43bf441483c5177fc85fd9d3',\n\tsystemSecret:test_secret}\n}}, function(e){\n\tcallback(e);\n});\n\n//single process mode \nservice.initialize({port:testport, services:{\n\tauth:{\n\t\tauthTokenSecret:'a256a2fd43bf441483c5177fc85fd9d3',\n\t\tsystemSecret:test_secret\n\t},\n\tdata:{}\n}}, function(e){\n\tcallback(e);\n});\n\n```\n\nIn your console, go to your application folder and run *node main* your server should start up and be listening on your port of choice.\n\nConnecting to Freebase\n-------------------------\n\nUsing node:\n\n```javascript\n var freebase = require('freebase'); \n var freebase_client = freebase.client; \n var my_client_instance; \n\n \tfreebase_client.newClient({host:'localhost', \n\t\t\t\t\t\t  port:80, \n\t\t\t\t\t\t  secret:'my test secret'}, function(e, my_client_instance){\n\n\t\t\t\t\t\t  //if no e, then you have been passed back a client in the client variable\n\t\t\t\t\t\t  if (!e)\n\t\t\t\t\t\t  \tmy_client_instance.get...\n\n```\n\nTo use the browser client, make sure the server is running, and reference the client javascript with the url pointing to the running server instances port and ip address like so:\n\n```html\n<script type=\"text/javascript\" src=\"http://localhost:80/browser_client\"></script>\n<script>\n//Thanks to the magic of browserify.org the browser client works exactly the same way as what the node client does, and can immediately be referenced like this:\n\n\tFreebaseBrowserClient.newClient({host:'localhost', port:80, secret:'my test secret'}, function(e, my_client_instance){\n\n               if (!e){\n\n               \t//instance.get...\n               \t//instance.set...\n               \t//instance.on...\n\n               }\n\n    });\n</script>\n```\n\nPUT\n-------------------------\n\n*Puts the json in the branch e2e_test1/testsubscribe/data, creates the branch if it does not exist*\n\n```javascript\nmy_client_instance.set('e2e_test1/testsubscribe/data', //the path you want to push your data to\n\t{property1:'property1',property2:'property2',property3:'property3'}, //your data\n\t{merge:true}, //options - can be null\n\tfunction(e, result){\t\n\t\tif (!e){\n\t\t\t//successful\n\t\t\tconsole.log(result.payload);//payload is an object with the result with an _id and containing a [data] property with yr uploaded data\n\n```\n\n*NB - by setting the option merge:true, the data at the end of the path is not overwritten by your json, it is rather merged with the data in your json, overwriting the fields you specify in your set data, but leaving the fields that are already at that branch.*\n\nPUT CHILD\n-------------------------\n\n*Posts your data to a collection that lives at the end of the specified branch (creates the collection if it doesnt exist), the getChild method will fetch your data back*\n\n```javascript\nmy_client_instance.setChild('e2e_test1/testsubscribe/data/collection', {property1:'post_property1',property2:'post_property2'}, function(e, results){\n\n\t\t\t\t\tif (!e){\n\t\t\t\t\t\t//the child method returns a child in the collection with a specified id\n\t\t\t\t\t\tmy_client_instance.getChild('e2e_test1/testsubscribe/data/collection', results.payload._id, function(e, results){\n```\n\nPUT SIBLING\n-------------------------\n\n*Posts your data to a unique path starting with the path you passed in as a parameter*\n\n```javascript\n\tmy_client_instance.setSibling('e2e_test1/siblings', {property1:'sib_post_property1',property2:'sib_post_property2'}, function(e, results){\n\t\t//you would get all siblings by querying the path e2e_test1/siblings*\n```\n\nGET\n---------------------------\n\n*Gets the data living at the specified branch, gets the whole collection if the data is a collection, see the child method (above) for getting a specific item from a collection*\n\n```javascript\nmy_client_instance.get('e2e_test1/testsubscribe/data', \n\tnull, //options\n\tfunction(e, results){\n\t//results is your data\n\tconsole.log(results.payload.length);//payload is now an array containing all the results for your get, get can also use a wildcard * in the path ie. publisherclient.get('e2e_test1/testsubscribe/data*'...\n```\n\n*You can also use wildcards, gets all items with the path starting e2e_test1/testsubscribe/data *\n\n```javascript\nmy_client_instance.get('e2e_test1/testsubscribe/data*', \n\tnull, \n\tfunction(e, results){\n\t//results is your data\n\tconsole.log(results.payload.length);//payload is now an array containing all the results for your get, get can also use a wildcard * in the path ie. publisherclient.get('e2e_test1/testsubscribe/data*'...\n```\n\n*You can also just get paths and ids, without data *\n\n```javascript\nmy_client_instance.getPaths('e2e_test1/testwildcard/*', function(e, results){\n```\n\nSEARCH\n---------------------------\n\n*You can pass mongo style search parameters to look for data sets within specific key ranges*\n\n```javascript\n\n\tparameters1 = {\n\t\tcriteria:{\n\t\t\t$or: [ {\"data.regions\": { $in: ['North','South','East','West'] }}, \n\t\t\t\t   {\"data.towns\": { $in: ['North.Cape Town', 'South.East London'] }}, \n\t\t\t\t   {\"data.categories\": { $in: [\"Action\",\"History\" ] }}],\n\t\t\t\"data.keywords\": {$in: [\"bass\", \"Penny Siopis\" ]}\n\t\t},\n\t\tfields:{\"data\":1},\n\t\tsort:{\"data.field1\":1},\n\t\tlimit:1\n\t}\n\n\tmy_client_instance.search('/e2e_test1/testsubscribe/data/complex*', parameters1, function(e, search_result){\n\n```\n\nDELETE\n---------------------------\n\n*Deletes the data living at the specified branch, if a child_id is specified, the child from the collection at the end of the branch is deleted*\n\n```javascript\n\tmy_client_instance.remove('/e2e_test1/testsubscribe/data/delete_me', null, function(e, result){\n\tif (!e)\n\t\t//your item was deleted, result.payload is an object that lists the amount of objects deleted\n```\n\nDELETE CHILD\n----------------------------\n\n*Deletes a child from an array living at a branch *\n\n```javascript\n//first we put\nmy_client_instance.setChild('/e2e_test1/testsubscribe/data/catch_all_array', {property1:'property1',property2:'property2',property3:'property3'}, function(e, post_result){\n\tif (!e){\n\t\t//your item was added to a collection, now remove it\n\t\tmy_client_instance.removeChild('/e2e_test1/testsubscribe/data/catch_all_array', post_result.payload._id, function(e, del_ar_result){\n\n\t\t\t\t\t\t\t\t\n```\n\nEVENTS\n----------------------------\n\n*You can listen to any PUT, POST and DELETE events happeneing in your data - you can specifiy a path you want to listen on or you can listen to all PUT, POST and DELETE using a catch-all listener*\n\nSpecific listener:\n```javascript\nmy_client_instance.on('/e2e_test1/testsubscribe/data/delete_me', //the path you are listening on\n\t\t\t\t\t  'DELETE', //either PUT,POST,DELETE\n\t\t\t\t\t  1, //how many times you want your listener event handler to fire - in this case your listener function will only fire once\n\t\t\t\t\t  function(e, message){ //your listener event handler\n```\n\nCatch all listener:\n```javascript\nmy_client_instance.onAll(function(e, message){\n\n\t\t\t//message consists of action property - POST,PUT, DELETE\n\t\t\t//and payload property - the actual data that got PUT, POSTED - or the _id of the data that got DELETED\n\n\n\t\t}, function(e){\n\n```\n\nTAGGING\n----------------------------\n\n*You can do a set command and specify that you want to tag the data at the end of the path (or the data that is created as a result of the command), tagging will take a snapshot of the data as it currently stands, and will save the snapshot to a path that starts with the path you specify, and a '/' with the tag you specify at the end *\n\n```javascript\n\nvar randomTag = require('shortid').generate();\n\nmy_client_instance.set('e2e_test1/test/tag', {property1:'property1',property2:'property2',property3:'property3'}, {tag:randomTag}, function(e, result){\n\n```\n\n",
  "readmeFilename": "README.md",
  "_id": "freebase@0.1.10",
  "_shasum": "1785fda4674232c65c91deadcd6e5306f771a620",
  "_from": "git+https://github.com/southbite/freebase.git",
  "_resolved": "git+https://github.com/southbite/freebase.git#36c12fcdec7dacab77e678e7fce7572b84bf3476"
}
